/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Alena Gusakov
-/
import Mathlib.Algebra.GeomSum
import Mathlib.Data.Finset.Slice
import Mathlib.Order.SupClosed

#align_import combinatorics.colex from "leanprover-community/mathlib"@"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c"

/-!
# Colexigraphic order

We define the colex order for finite sets, and give a couple of important lemmas and properties
relating to it.

The colex ordering likes to avoid large values: If the biggest element of `t` is bigger than all elements of `s`, then `s < t`.

In the special case of `‚Ñï`, it can be thought of as the "binary" ordering. That is, order `s` based
on `‚àë_{i ‚àà s} 2^i`. It's defined here on `Finset Œ±` for any linear order `Œ±`.

In the context of the Kruskal-Katona theorem, we are interested in how colex behaves for sets of a
fixed size. For example, for size 3, the colex order on ‚Ñï starts
`123, 124, 134, 234, 125, 135, 235, 145, 245, 345, ...`

## Main statements

* Colex order properties - linearity, decidability and so on.
* `Finset.Colex.forall_lt_mono`: if `s < t` in colex, and everything in `t` is `< a`, then
  everything in `s` is `< a`. This confirms the idea that an enumeration under colex will exhaust
  all sets using elements `< a` before allowing `a` to be included.
* `Finse.toColex_image_lt_toColex_image`: Strictly monotone functions preserve colex.
* `Finset.sum_two_pow_le_iff_colex_le`: colex for Œ± = ‚Ñï is the same as binary
  (this also proves binary expansions are unique)

## See also

Related files are:
* `Data.List.Lex`: Lexicographic order on lists.
* `Data.Pi.Lex`: Lexicographic order on `Œ†‚Çó i, Œ± i`.
* `Data.PSigma.Order`: Lexicographic order on `Œ£' i, Œ± i`.
* `Data.Sigma.Order`: Lexicographic order on `Œ£ i, Œ± i`.
* `Data.Prod.Lex`: Lexicographic order on `Œ± √ó Œ≤`.

## TODO

* Generalise `Colex.initSeg` so that it applies to `‚Ñï`.

## References

* https://github.com/b-mehta/maths-notes/blob/master/iii/mich/combinatorics.pdf

## Tags

colex, colexicographic, binary
-/

open Finset
open scoped BigOperators

/-- If all the elements of a finset `s` of naturals are less than `n`, then the sum of their powers of `2` is less than `2 ^ k`. -/
lemma Nat.sum_two_pow_lt {n : ‚Ñï} {s : Finset ‚Ñï} (hs : ‚àÄ k ‚àà s, k < n) :
    ‚àë k in s, 2 ^ k < 2 ^ n := by
  calc
    ‚àë k in s, 2 ^ k ‚â§ ‚àë k in range n, 2 ^ k := sum_le_sum_of_subset fun k hk ‚Ü¶ mem_range.2 $ hs _ hk
    _ = 2 ^ n - 1 := by
        simp_rw [‚Üêone_add_one_eq_two, ‚Üêgeom_sum_mul_add 1 n, mul_one, add_tsub_cancel_right]
    _ < 2 ^ n := tsub_lt_self (by positivity) zero_lt_one
#align nat.sum_two_pow_lt Nat.sum_two_pow_lt

variable {Œ± Œ≤ : Type*}

namespace Finset

/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion
order. -/
@[ext]
structure Colex (Œ±) := toColex :: (ofColex : Finset Œ±)

-- TODO: Why can't we export?
--export Colex (toColex)

open Colex

/-- `toColex` is the "identity" function between `Finset Œ±` and `Finset.Colex Œ±`. -/
add_decl_doc toColex

/-- `ofColex` is the "identity" function between `Finset.Colex Œ±` and `Finset Œ±`. -/
add_decl_doc ofColex

instance : Inhabited (Colex Œ±) := ‚ü®‚ü®‚àÖ‚ü©‚ü©

@[simp] lemma toColex_ofColex (s : Colex Œ±) : toColex (ofColex s) = s := rfl
lemma ofColex_toColex (s : Finset Œ±) : ofColex (toColex s) = s := rfl
lemma toColex_inj {s t : Finset Œ±} : toColex s = toColex t ‚Üî s = t := by simp
@[simp] lemma ofColex_inj {s t : Colex Œ±} : ofColex s = ofColex t ‚Üî s = t := by cases s; cases t; simp
lemma toColex_ne_toColex {s t : Finset Œ±} : toColex s ‚â† toColex t ‚Üî s ‚â† t := by simp
lemma ofColex_ne_ofColex {s t : Colex Œ±} : ofColex s ‚â† ofColex t ‚Üî s ‚â† t := by simp

namespace Colex
section LT
variable [LT Œ±] {s t u : Finset Œ±}

/-- `s` is less than `t` in the colex ordering if the largest thing that's not in both sets is in t.
In other words, `max (s ‚àÜ t) ‚àà t` (if the maximum exists). -/
instance instLT : LT (Colex Œ±) :=
  ‚ü®fun s t ‚Ü¶ ‚àÉ a, (‚àÄ ‚¶Éx‚¶Ñ, a < x ‚Üí (x ‚àà ofColex s ‚Üî x ‚àà ofColex t)) ‚àß a ‚àâ ofColex s ‚àß a ‚àà ofColex t‚ü©

/-- We can define (‚â§) in the obvious way. -/
instance instLE : LE (Colex Œ±) := ‚ü®fun s t ‚Ü¶ s = t ‚à® s < t‚ü©

lemma lt_def {s t : Colex Œ±} :
    s < t ‚Üî ‚àÉ a, (‚àÄ ‚¶Éx‚¶Ñ, a < x ‚Üí (x ‚àà ofColex s ‚Üî x ‚àà ofColex t)) ‚àß a ‚àâ ofColex s ‚àß a ‚àà ofColex t :=
  Iff.rfl

lemma le_def {s t : Colex Œ±} :
    s ‚â§ t ‚Üî s = t ‚à®
      ‚àÉ a, (‚àÄ ‚¶Éx‚¶Ñ, a < x ‚Üí (x ‚àà ofColex s ‚Üî x ‚àà ofColex t)) ‚àß a ‚àâ ofColex s ‚àß a ‚àà ofColex t :=
  Iff.rfl

lemma toColex_lt_toColex :
    toColex s < toColex t ‚Üî ‚àÉ k, (‚àÄ ‚¶Éx‚¶Ñ, k < x ‚Üí (x ‚àà s ‚Üî x ‚àà t)) ‚àß k ‚àâ s ‚àß k ‚àà t := Iff.rfl

lemma toColex_le_toColex :
    toColex s ‚â§ toColex t ‚Üî s = t ‚à® ‚àÉ k, (‚àÄ ‚¶Éx‚¶Ñ, k < x ‚Üí (x ‚àà s ‚Üî x ‚àà t)) ‚àß k ‚àâ s ‚àß k ‚àà t := by
  simp [le_def]

instance instIsIrrefl : IsIrrefl (Colex Œ±) (¬∑ < ¬∑) := ‚ü®by simp [lt_def]‚ü©

variable [DecidableEq Œ±]

/-- The colexigraphic order is insensitive to removing elements. -/
lemma toColex_sdiff_lt_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :
    toColex (s \ u) < toColex (t \ u) ‚Üî toColex s < toColex t := by
  simp only [toColex_lt_toColex, toColex_lt_toColex, mem_sdiff, not_and, not_not]
  refine exists_congr fun k ‚Ü¶ ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®h, hksu, hkt, hku‚ü©
    refine ‚ü®fun x hx ‚Ü¶ ?_, mt hksu hku, hkt‚ü©
    specialize h hx
    tauto
  ¬∑ rintro ‚ü®h, hks, hkt‚ü©
    exact ‚ü®fun x hx ‚Ü¶ by rw [h hx], fun hks' ‚Ü¶ (hks hks').elim, hkt, not_mem_mono hus hks‚ü©

@[simp] lemma toColex_sdiff_lt_toColex_sdiff' :
 toColex (s \ t) < toColex (t \ s) ‚Üî toColex s < toColex t := by
  simpa using toColex_sdiff_lt_toColex_sdiff (inter_subset_left s t) (inter_subset_right s t)

end LT

section LinearOrder
variable [LinearOrder Œ±] [LinearOrder Œ≤] {f : Œ± ‚Üí Œ≤} {ùíú ùíú‚ÇÅ ùíú‚ÇÇ : Finset (Finset Œ±)}
  {s t u : Finset Œ±} {a b : Œ±} {r : ‚Ñï}

instance : IsStrictTotalOrder (Colex Œ±) (¬∑ < ¬∑) where
  irrefl := irrefl_of (¬∑ < ¬∑)
  trans s t u := by
    rintro ‚ü®k‚ÇÅ, k‚ÇÅz, notinA, inB‚ü© ‚ü®k‚ÇÇ, k‚ÇÇz, notinB, inC‚ü©
    obtain h | h := (ne_of_mem_of_not_mem inB notinB).lt_or_lt
    ¬∑ refine' ‚ü®k‚ÇÇ, fun x hx ‚Ü¶ _, by rwa [k‚ÇÅz h], inC‚ü©
      rw [‚Üêk‚ÇÇz hx]
      exact k‚ÇÅz (h.trans hx)
    ¬∑ refine' ‚ü®k‚ÇÅ, fun x hx ‚Ü¶ _, notinA, by rwa [‚Üêk‚ÇÇz h]‚ü©
      rw [k‚ÇÅz hx]
      exact k‚ÇÇz (h.trans hx)
  trichotomous s t := by
    classical
    obtain rfl | hts := eq_or_ne t s
    ¬∑ simp
    obtain ‚ü®k, hk, z‚ü© := exists_max_image _ id (symmDiff_nonempty.2 $ ofColex_ne_ofColex.2 hts)
    refine' (mem_symmDiff.1 hk).imp (fun hk => ‚ü®k, fun a ha ‚Ü¶ _, hk.2, hk.1‚ü©) fun hk ‚Ü¶
        Or.inr ‚ü®k, fun a ha ‚Ü¶ _, hk.2, hk.1‚ü© <;>
      simpa [mem_symmDiff, not_or, iff_iff_implies_and_implies, and_comm, not_imp_not]
        using not_imp_not.2 (z a) ha.not_le

instance instDecidableLT : @DecidableRel (Colex Œ±) (¬∑ < ¬∑) := fun s t ‚Ü¶
  decidable_of_iff'
    (‚àÉ k ‚àà ofColex t,
      (‚àÄ x ‚àà ofColex s ‚à™ ofColex t, k < x ‚Üí (x ‚àà ofColex s ‚Üî x ‚àà ofColex t)) ‚àß k ‚àâ ofColex s) $
    exists_congr fun a ‚Ü¶ by
      simp only [mem_union, exists_prop, or_imp, @and_comm (_ ‚àà ofColex t), and_assoc]
      exact and_congr_left' $ forall_congr' $ by tauto

instance instLinearOrder : LinearOrder (Colex Œ±) := linearOrderOfSTO (¬∑ < ¬∑)

instance instBot : Bot (Colex Œ±) where
  bot := toColex ‚àÖ

@[simp] lemma toColex_empty : toColex (‚àÖ : Finset Œ±) = ‚ä• := rfl
@[simp] lemma ofColex_bot : ofColex (‚ä• : Colex Œ±) = ‚àÖ := rfl

instance instOrderBot : OrderBot (Colex Œ±) where
  bot_le s := by
    induction' s using Finset.Colex.rec with s
    rw [le_def]
    obtain rfl | hs := s.eq_empty_or_nonempty
    ¬∑ simp
    refine' Or.inr ‚ü®max' _ hs, _, by simp, max'_mem _ _‚ü©
    simp only [max'_lt_iff, ofColex_bot, not_mem_empty, ofColex_toColex, false_iff]
    exact fun x hs hx ‚Ü¶ lt_irrefl _ $ hs _ hx

/-- The colexigraphic order is insensitive to removing elements. -/
lemma toColex_sdiff_le_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :
    toColex (s \ u) ‚â§ toColex (t \ u) ‚Üî toColex s ‚â§ toColex t := by
  rw [le_iff_le_iff_lt_iff_lt, toColex_sdiff_lt_toColex_sdiff hut hus]

@[simp] lemma toColex_sdiff_le_toColex_sdiff' :
    toColex (s \ t) ‚â§ toColex (t \ s) ‚Üî toColex s ‚â§ toColex t := by
  rw [le_iff_le_iff_lt_iff_lt, toColex_sdiff_lt_toColex_sdiff']

lemma colex_lt_of_ssubset (h : s ‚äÇ t) : toColex s < toColex t := by
  rw [‚ÜêtoColex_sdiff_lt_toColex_sdiff', sdiff_eq_empty_iff_subset.2 h.1, toColex_empty,
    bot_lt_iff_ne_bot, ‚ÜêtoColex_empty, toColex_ne_toColex]
  simpa using h.not_subset

/-- If `s ‚äÜ t`, then `s ‚â§ t` in the colex order. Note the converse does not hold, as `‚äÜ` is not a
linear order. -/
lemma colex_le_of_subset (h : s ‚äÜ t) : toColex s ‚â§ toColex t := by
  rw [‚ÜêtoColex_sdiff_le_toColex_sdiff', sdiff_eq_empty_iff_subset.2 h, toColex_empty]; exact bot_le

instance [Fintype Œ±] : BoundedOrder (Colex Œ±) where
    top := toColex univ
    le_top _x := colex_le_of_subset (subset_univ _)

@[simp] lemma toColex_univ [Fintype Œ±] : toColex (univ : Finset Œ±) = ‚ä§ := rfl
@[simp] lemma ofColex_top [Fintype Œ±] : ofColex (‚ä§ : Colex Œ±) = univ := rfl

/-- `s < {a}` in colex iff all elements of `s` are strictly less than `a`. -/
lemma toColex_lt_singleton : toColex s < toColex {a} ‚Üî ‚àÄ x ‚àà s, x < a := by
  simp only [toColex_lt_toColex, mem_singleton, ‚Üêand_assoc, exists_eq_right, ‚Üênot_le (a := a)]
  refine ‚ü®fun t x hx hax ‚Ü¶ ?_, fun h ‚Ü¶ ‚ü®fun z hz ‚Ü¶ ?_, by simpa using h a‚ü©‚ü©
  ¬∑ obtain hax | rfl := hax.lt_or_eq
    ¬∑ exact hax.ne' $ (t.1 hax).1 hx
    ¬∑ exact t.2 hx
  ¬∑ exact ‚ü®fun i ‚Ü¶ ((h _ i) hz.le).elim, fun i ‚Ü¶ (hz.ne' i).elim‚ü©

/-- `{a} ‚â§ s` in colex iff `r` contains an element greated than or equal to `a`. -/
lemma singleton_le_toColex : (toColex {a} : Colex Œ±) ‚â§ toColex s ‚Üî ‚àÉ x ‚àà s, a ‚â§ x := by
  simp only [‚Üênot_lt, toColex_lt_singleton, not_forall, exists_prop]

/-- Colex is an extension of the base order. -/
lemma singleton_lt_singleton : (toColex {a} : Colex Œ±) < toColex {b} ‚Üî a < b := by
  simp [toColex_lt_singleton]

/-- Colex is an extension of the base order. -/
lemma singleton_le_singleton : (toColex {a} : Colex Œ±) ‚â§ toColex {b} ‚Üî a ‚â§ b := by
  rw [le_iff_le_iff_lt_iff_lt, singleton_lt_singleton]

/-- If `s` is before `t` in colex, and everything in `t` is small, then everything in `s` is small.
-/
lemma forall_lt_mono (h‚ÇÅ : toColex s ‚â§ toColex t) (h‚ÇÇ : ‚àÄ x ‚àà t, x < a) : ‚àÄ x ‚àà s, x < a := by
  obtain rfl | ‚ü®k, z, -, hk‚ü© := toColex_le_toColex.1 h‚ÇÅ
  ¬∑ assumption
  ¬∑ refine' fun x hx => lt_of_not_le fun h ‚Ü¶ h.not_lt $ h‚ÇÇ x _
    rwa [‚Üêz ((h‚ÇÇ k hk).trans_le h)]

/-- Strictly monotone functions preserve the colex ordering. -/
lemma toColex_image_lt_toColex_image (hf : StrictMono f) :
    toColex (s.image f) < toColex (t.image f) ‚Üî toColex s < toColex t := by
  simp only [toColex_lt_toColex, not_exists, mem_image, exists_prop, not_and]
  constructor
  ¬∑ rintro ‚ü®k, z, q, k', _, rfl‚ü©
    exact ‚ü®k', fun x hx => by simpa [hf.injective.eq_iff] using z (hf hx),
      fun t ‚Ü¶ q _ t rfl, ‚Äπk' ‚àà t‚Ä∫‚ü©
  rintro ‚ü®k, z, ka, _‚ü©
  refine' ‚ü®f k, fun x hx ‚Ü¶ _, _, k, ‚Äπk ‚àà t‚Ä∫, rfl‚ü©
  ¬∑ constructor
    all_goals
      rintro ‚ü®x', hx', rfl‚ü©
      refine' ‚ü®x', _, rfl‚ü©
      first
      | rwa [‚Üêz _]
      | rwa [z _]
      rwa [StrictMono.lt_iff_lt hf] at hx
  ¬∑ simp only [hf.injective, Function.Injective.eq_iff]
    exact fun x hx ‚Ü¶ ne_of_mem_of_not_mem hx ka

/-- Strictly monotone functions preserve the colex ordering. -/
lemma toColex_image_le_toColex_image (hf : StrictMono f) :
    toColex (s.image f) ‚â§ toColex (t.image f) ‚Üî toColex s ‚â§ toColex t := by
  rw [le_iff_le_iff_lt_iff_lt, toColex_image_lt_toColex_image hf]

/-! ### Initial segments -/

/-- `ùíú` is an initial segment of the colexigraphic order on sets of `r`, and that if `t` is below
`s` in colex where `t` has size `r` and `s` is in `ùíú`, then `t` is also in `ùíú`. In effect, `ùíú` is
downwards closed with respect to colex among sets of size `r`. -/
def IsInitSeg (ùíú : Finset (Finset Œ±)) (r : ‚Ñï) : Prop :=
  (ùíú : Set (Finset Œ±)).Sized r ‚àß
    ‚àÄ ‚¶És t : Finset Œ±‚¶Ñ, s ‚àà ùíú ‚Üí toColex t < toColex s ‚àß t.card = r ‚Üí t ‚àà ùíú

@[simp] lemma isInitSeg_empty : IsInitSeg (‚àÖ : Finset (Finset Œ±)) r := by simp [IsInitSeg]

/-- Initial segments are nested in some way. In particular, if they're the same size they're equal.
-/
lemma IsInitSeg.total (h‚ÇÅ : IsInitSeg ùíú‚ÇÅ r) (h‚ÇÇ : IsInitSeg ùíú‚ÇÇ r) : ùíú‚ÇÅ ‚äÜ ùíú‚ÇÇ ‚à® ùíú‚ÇÇ ‚äÜ ùíú‚ÇÅ := by
  classical
  simp_rw [‚Üêsdiff_eq_empty_iff_subset, ‚Üênot_nonempty_iff_eq_empty]
  by_contra' h
  obtain ‚ü®‚ü®s, hs‚ü©, t, ht‚ü© := h
  rw [mem_sdiff] at hs ht
  obtain hst | hst | hts := trichotomous_of (Œ± := Colex Œ±) (¬∑ < ¬∑) (toColex s) (toColex t)
  ¬∑ exact hs.2 $ h‚ÇÇ.2 ht.1 ‚ü®hst, h‚ÇÅ.1 hs.1‚ü©
  ¬∑ simp only [toColex.injEq] at hst
    exact ht.2 $ hst ‚ñ∏ hs.1
  ¬∑ exact ht.2 $ h‚ÇÅ.2 hs.1 ‚ü®hts, h‚ÇÇ.1 ht.1‚ü©

variable [Fintype Œ±]

/-- Gives all sets up to `s` with the same size as it: this is equivalent to
being an initial segment of colex. -/
def initSeg (s : Finset Œ±) : Finset (Finset Œ±) :=
  univ.filter fun t ‚Ü¶ s.card = t.card ‚àß toColex t ‚â§ toColex s

@[simp]
lemma mem_initSeg : t ‚àà initSeg s ‚Üî s.card = t.card ‚àß toColex t ‚â§ toColex s := by simp [initSeg]

lemma mem_initSeg_self : s ‚àà initSeg s := by simp
@[simp] lemma initSeg_nonempty : (initSeg s).Nonempty := ‚ü®s, mem_initSeg_self‚ü©

lemma isInitSeg_initSeg : IsInitSeg (initSeg s) s.card := by
  refine ‚ü®fun t ht => (mem_initSeg.1 ht).1.symm, fun t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ ‚Ü¶ mem_initSeg.2 ‚ü®ht‚ÇÇ.2.symm, ?_‚ü©‚ü©
  rw [mem_initSeg] at ht‚ÇÅ
  exact ht‚ÇÇ.1.le.trans ht‚ÇÅ.2

lemma IsInitSeg.exists_initSeg (hùíú : IsInitSeg ùíú r) (hùíú‚ÇÄ : ùíú.Nonempty) :
    ‚àÉ s : Finset Œ±, s.card = r ‚àß ùíú = initSeg s := by
  have hs := sup'_mem (ofColex ‚Åª¬π' ùíú) (LinearOrder.supClosed _) ùíú hùíú‚ÇÄ toColex
    (fun a ha ‚Ü¶ by simpa using ha)
  refine' ‚ü®_, hùíú.1 hs, _‚ü©
  ext t
  rw [mem_initSeg]
  refine' ‚ü®fun p ‚Ü¶ _, _‚ü©
  ¬∑ rw [hùíú.1 p, hùíú.1 hs]
    exact ‚ü®rfl, le_sup' _ p‚ü©
  rintro ‚ü®cards, le‚ü©
  obtain p | p := le.eq_or_lt
  ¬∑ rwa [toColex_inj.1 p]
  ¬∑ exact hùíú.2 hs ‚ü®p, cards ‚ñ∏ hùíú.1 hs‚ü©

/-- Being a nonempty initial segment of colex if equivalent to being an `initSeg`. -/
lemma isInitSeg_iff_exists_initSeg :
    IsInitSeg ùíú r ‚àß ùíú.Nonempty ‚Üî ‚àÉ s : Finset Œ±, s.card = r ‚àß ùíú = initSeg s := by
  refine ‚ü®fun hùíú ‚Ü¶ hùíú.1.exists_initSeg hùíú.2, ?_‚ü©
  rintro ‚ü®s, rfl, rfl‚ü©
  exact ‚ü®isInitSeg_initSeg, initSeg_nonempty‚ü©

end LinearOrder
end Colex

open Colex

/-!
### Colex on `‚Ñï`

The colexicographic order agrees with the order induced by interpreting a set of naturals as a
binary expansion.
-/

section Nat
variable {s t : Finset ‚Ñï}

/-- For finsets of naturals of naturals, the colexicographic order is equivalent to the order
induced by the binary expansion. -/
lemma sum_two_pow_lt_iff_colex_lt : ‚àë i in s, 2 ^ i < ‚àë i in t, 2 ^ i ‚Üî toColex s < toColex t := by
  have z : ‚àÄ s t : Finset ‚Ñï, toColex s < toColex t ‚Üí ‚àë i in s, 2 ^ i < ‚àë i in t, 2 ^ i := by
    intro s t
    rw [‚ÜêtoColex_sdiff_lt_toColex_sdiff', toColex_lt_toColex]
    rintro ‚ü®a, ha, has, hat‚ü©
    rw [‚Üêsdiff_union_inter s t]
    conv_rhs => rw [‚Üêsdiff_union_inter t s]
    rw [sum_union (disjoint_sdiff_inter _ _), sum_union (disjoint_sdiff_inter _ _), inter_comm,
      add_lt_add_iff_right]
    apply (@Nat.sum_two_pow_lt a (s \ t) _).trans_le
    ¬∑ apply single_le_sum (fun _ _ ‚Ü¶ Nat.zero_le _) hat
    intro x hx
    refine' (ne_of_mem_of_not_mem hx has).lt_or_lt.resolve_right $ fun hax ‚Ü¶ _
    have := (ha hax).1 hx
    rw [mem_sdiff] at this hx
    exact hx.2 this.1
  refine' ‚ü®fun h ‚Ü¶ (lt_trichotomy (toColex s) $ toColex t).resolve_right fun h‚ÇÅ ‚Ü¶
    h‚ÇÅ.elim _ (not_lt_of_gt h ‚àò z _ _), z s t‚ü©
  rw [toColex_inj]
  rintro rfl
  exact irrefl _ h

/-- For finsets of naturals of naturals, the colexicographic order is equivalent to the order
induced by the binary expansion. -/
lemma sum_two_pow_le_iff_colex_le : ‚àë i in s, 2 ^ i ‚â§ ‚àë i in t, 2 ^ i ‚Üî toColex s ‚â§ toColex t := by
  rw [le_iff_le_iff_lt_iff_lt, sum_two_pow_lt_iff_colex_lt]

end Nat
end Finset
